<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>מערכת מבחנים</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; direction: rtl; }
    h1 { margin-top: 0; }
    #selector { margin-bottom: 15px; }
    iframe { width: 100%; height: 600px; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>מערכת מבחנים</h1>
  <div id="selector">
    <label for="quizSelect">בחר מבחן:</label>
    <select id="quizSelect">
      <!-- options populated from quiz_catalog.json -->
    </select>

    <div id="vocabOptions" style="display:none; margin-top:10px; padding:10px; border:1px solid #ddd; border-radius:8px;">
      <div style="margin-bottom:10px;">
        <span style="font-weight:600;">סוג:</span>
        <label style="margin-inline-start:10px;"><input type="radio" name="vocabMode" value="drag" checked> מחסן (גרירה)</label>
        <label style="margin-inline-start:10px;"><input type="radio" name="vocabMode" value="open"> פתוח</label>
      </div>

      <div id="tagBox" style="margin-top:8px;">
        <div style="font-weight:600; margin-bottom:6px;">תגיות (הצג רק מילים מתוייגות):</div>
        <div id="tagList" style="display:flex; flex-wrap:wrap; gap:10px;"></div>
      </div>
    </div>

    <div id="amOptions" style="display:none; margin-top:10px; padding:10px; border:1px solid #ddd; border-radius:8px;">
      <div style="margin-bottom:10px;">
        <span style="font-weight:600;">סוג:</span>
        <label style="margin-inline-start:10px;"><input type="radio" name="amMode" value="mcq" checked> בחירה</label>
        <label style="margin-inline-start:10px;"><input type="radio" name="amMode" value="open"> פתוח</label>
      </div>
    </div>
  </div>
  <iframe id="quizFrame" src="quizzes/vocab/quiz.html?mode=drag"></iframe>

  <script>

    const sel = document.getElementById('quizSelect');
    const frame = document.getElementById('quizFrame');
    const vocabOptions = document.getElementById('vocabOptions');
    const tagList = document.getElementById('tagList');
    const amOptions = document.getElementById('amOptions');

    let vocabTags = [];
    let catalog = null;
    let quizById = {};

    async function loadCatalog() {
      if (catalog) return catalog;

      const params = new URLSearchParams(location.search);
      const name = (params.get('name') || '').trim();

      // Prefer per-name catalog: catalogs/<name>.json
      const perNameUrl = name ? ('catalogs/' + encodeURIComponent(name) + '.json') : null;

      async function tryFetch(url) {
        try {
          const r = await fetch(url, { cache: 'no-cache' });
          if (!r.ok) return null;
          return await r.json();
        } catch (e) {
          return null;
        }
      }

      const perNameCatalog = perNameUrl ? await tryFetch(perNameUrl) : null;
      catalog = perNameCatalog || await tryFetch('quiz_catalog.json') || { quizzes: [] };

      quizById = {};
      (catalog.quizzes || []).forEach(q => { if (q && q.id) quizById[q.id] = q; });

      // Optional: show who this catalog is for
      const whoEl = document.getElementById('catalog-owner');
      if (whoEl) {
        whoEl.textContent = name ? ('קטלוג: ' + name) : '';
      }

      return catalog;
    }

    async function populateSelect() {
      const cat = await loadCatalog();
      sel.innerHTML = '';
      (cat.quizzes || []).forEach(q => {
        const opt = document.createElement('option');
        opt.value = q.id;
        opt.textContent = q.title || q.id;
        sel.appendChild(opt);
      });
      // default to vocab if exists
      if (quizById['vocab']) sel.value = 'vocab';
    }

    async function sanitizeName(name) {
      // allow only letters, numbers, underscore, dash
      return (name || '').toString().trim().replace(/[^a-zA-Z0-9_-]/g, '');
    }

    const vocabTagsCache = {}; // key: name or '__default__' -> [tags]

    async function loadVocabTagsOnce() {
      const rawName = new URLSearchParams(window.location.search).get('name');
      const name = sanitizeName(rawName);
      const cacheKey = name || '__default__';
      if (vocabTagsCache[cacheKey]) return vocabTagsCache[cacheKey];

      try {
        // Prefer personalized questions_<name>.json when available
        let questions = null;

        if (name) {
          const personalizedPath = `quizzes/vocab/questions_${name}.json`;
          const res = await fetch(personalizedPath);
          if (res.ok) {
            questions = await res.json();
            console.log('Loaded personalized vocab tags from:', personalizedPath);
          }
        }

        if (!questions) {
          questions = await fetch('quizzes/vocab/questions.json').then(r => r.json());
        }

        const set = new Set();
        questions.forEach(q => (q.tags || []).forEach(t => set.add(t)));
        const tags = Array.from(set).sort((a,b) => a.localeCompare(b, 'he'));

        vocabTagsCache[cacheKey] = tags;
        return tags;
      } catch (e) {
        vocabTagsCache[cacheKey] = [];
        return vocabTagsCache[cacheKey];
      }
    }

    function getSelectedVocabMode() {
      const r = document.querySelector('input[name="vocabMode"]:checked');
      return r ? r.value : 'drag';
    }

    function getSelectedTags() {
      const checked = Array.from(document.querySelectorAll('input[name="vocabTag"]:checked'));
      return checked.map(x => x.value);
    }

    function getSelectedAmMode() {
      const r = document.querySelector('input[name="amMode"]:checked');
      return r ? r.value : 'mcq';
    }

    async function refreshVocabTagsUI() {
      const tags = await loadVocabTagsOnce();
      tagList.innerHTML = '';
      tags.forEach(t => {
        const label = document.createElement('label');
        label.style.display = 'inline-block';
        label.style.margin = '4px 8px';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.name = 'vocabTag';
        cb.value = t;
        label.appendChild(cb);
        label.appendChild(document.createTextNode(' ' + t));
        tagList.appendChild(label);
      });
    }

    function setFrameSrc(url) {
      frame.src = url;
    }

    function buildVocabUrl() {
      const q = quizById['vocab'];
      const base = (q && q.page) ? q.page : 'quizzes/vocab/quiz.html';
      const mode = getSelectedVocabMode();
      const tags = getSelectedTags();
      const params = new URLSearchParams();
      const outerName = new URLSearchParams(location.search).get('name');
      if (outerName) params.set('name', outerName);
      params.set('mode', mode);
      if (tags.length) params.set('tags', tags.join(','));
      return base + '?' + params.toString();
    }

    function buildAmUrl() {
      const q = quizById['am_is_are'];
      const base = (q && q.page) ? q.page : 'quizzes/am_is_are/quiz.html';
      const mode = getSelectedAmMode(); // mcq/open
      const params = new URLSearchParams();
      const outerName = new URLSearchParams(location.search).get('name');
      if (outerName) params.set('name', outerName);
      params.set('mode', mode);
      return base + '?' + params.toString();
    }

    function hideAllOptions() {
      vocabOptions.style.display = 'none';
      amOptions.style.display = 'none';
    }

    async function onSelectChanged() {
      const id = sel.value;
      hideAllOptions();

      if (id === 'vocab') {
        vocabOptions.style.display = 'block';
        await refreshVocabTagsUI();
        setFrameSrc(buildVocabUrl());
        return;
      }

      if (id === 'am_is_are') {
        amOptions.style.display = 'block';
        setFrameSrc(buildAmUrl());
        return;
      }

      const q = quizById[id];
      if (q && q.page) {
        setFrameSrc(q.page);
      } else {
        // Fallback: treat as direct URL if catalog is missing/old
        setFrameSrc(id);
      }
    }

    // Wire UI events
    sel.addEventListener('change', onSelectChanged);
    document.querySelectorAll('input[name="vocabMode"]').forEach(r => r.addEventListener('change', () => setFrameSrc(buildVocabUrl())));
    document.addEventListener('change', (e) => {
      if (e.target && e.target.name === 'vocabTag') setFrameSrc(buildVocabUrl());
      if (e.target && e.target.name === 'amMode') setFrameSrc(buildAmUrl());
    });

    (async () => {
      await populateSelect();
      await onSelectChanged();
    })();

  </script>
</body>
</html>
